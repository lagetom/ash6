<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>ğŸ‘” ì´ë¯¸ì§€ ë¦¬í¼ì‹¤</title>
  
  <!-- [iOS PWA ì„¤ì •] -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="ë¦¬í¼ì‹¤" />
  <link rel="apple-touch-icon" href="https://lagetom.github.io/ash/icon.png" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+KR:wght@400;500;600&display=swap" rel="stylesheet">
  <!-- Google AdSense -->
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6097617241369024"
   crossorigin="anonymous"></script>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      font-family: 'IBM Plex Sans KR', -apple-system, BlinkMacSystemFont, sans-serif;
      background: linear-gradient(135deg, #1a1f3a 0%, #2d4578 30%, #4a6fa5 60%, #ff8a65 85%, #ffab91 100%);
      min-height: 100vh;
      padding: 20px;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      position: relative;
      overflow-x: hidden;
      overscroll-behavior: none;
      -webkit-user-select: none;
      user-select: none;
      padding-top: env(safe-area-inset-top);
    }

    /* íŒŒë„ ì• ë‹ˆë©”ì´ì…˜ */
    @keyframes wave {
      0%, 100% { transform: translateX(0) translateY(0); }
      25% { transform: translateX(-5%) translateY(-2%); }
      50% { transform: translateX(-10%) translateY(0); }
      75% { transform: translateX(-5%) translateY(2%); }
    }

    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 200%;
      height: 100%;
      background: 
        radial-gradient(ellipse at 30% 60%, rgba(74, 111, 165, 0.3) 0%, transparent 50%),
        radial-gradient(ellipse at 70% 40%, rgba(255, 138, 101, 0.25) 0%, transparent 50%);
      animation: wave 15s ease-in-out infinite;
      pointer-events: none;
      z-index: 0;
    }

    input[type="text"], input[type="number"] { -webkit-user-select: text; user-select: text; }

    .container {
      position: relative;
      z-index: 1;
      width: 100%;
      max-width: 600px;
      background: rgba(255, 255, 255, 0.97);
      backdrop-filter: blur(15px);
      -webkit-backdrop-filter: blur(15px);
      border-radius: 32px;
      padding: 30px;
      box-shadow: 
        0 20px 60px rgba(0, 0, 0, 0.3),
        0 0 0 1px rgba(255, 255, 255, 0.5) inset;
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    h1 {
      font-size: 24px;
      font-weight: 600;
      background: linear-gradient(135deg, #2d4578 0%, #ff8a65 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .header-buttons {
      display: flex;
      gap: 8px;
    }

    .header-btn {
      background: linear-gradient(135deg, #4a6fa5 0%, #2d4578 100%);
      color: white;
      border: none;
      border-radius: 10px;
      padding: 8px 12px;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(74, 111, 165, 0.3);
      text-decoration: none;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .header-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(74, 111, 165, 0.4);
    }

    p.subtitle {
      color: #666;
      line-height: 1.7;
      text-align: center;
      margin-bottom: 20px;
      font-size: 14px;
    }

    /* ì—…ë¡œë“œ ì˜ì—­ */
    .upload-box {
      border: 3px dashed #e0e0e0;
      border-radius: 16px;
      padding: 50px 20px;
      cursor: pointer;
      text-align: center;
      transition: all 0.3s;
      min-height: 180px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: #f8f9fa;
    }

    .upload-box:hover, .upload-box.dragover {
      background: #e3f2fd;
      border-color: #4a6fa5;
    }

    .upload-box p {
      color: #666;
      margin-top: 10px;
    }

    /* ìº”ë²„ìŠ¤ ì˜ì—­ */
    #workspace { display: none; text-align: center; }

    #canvas-wrapper {
      position: relative;
      display: inline-block;
      margin: 10px auto;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
      touch-action: none;
      max-width: 100%;
      cursor: none;
    }

    canvas { display: block; max-width: 100%; height: auto; }

    /* ë¸ŒëŸ¬ì‹œ ë¯¸ë¦¬ë³´ê¸° */
    #brush-cursor {
      position: absolute;
      border: 1px solid rgba(0,0,0,0.5);
      background-color: rgba(255,255,255,0.2);
      border-radius: 50%;
      pointer-events: none;
      transform: translate(-50%, -50%);
      z-index: 10;
      display: none;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      overflow: hidden;
      white-space: nowrap;
    }

    /* ë„êµ¬ íŒ¨ë„ */
    .toolbar {
      display: flex;
      flex-direction: column;
      gap: 10px;
      background: #f8f9fa;
      padding: 15px;
      border-radius: 14px;
      margin-bottom: 15px;
      border: 2px solid #e0e0e0;
      align-items: center;
    }

    .tool-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: center;
      width: 100%;
    }

    .tool-btn {
      background: #fff;
      color: #333;
      border: 2px solid #e0e0e0;
      width: 44px;
      height: 44px;
      border-radius: 10px;
      cursor: pointer;
      font-size: 1.2rem;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .tool-btn:hover {
      background: #e3f2fd;
      border-color: #4a6fa5;
    }

    .tool-btn.active {
      background: linear-gradient(135deg, #4a6fa5 0%, #2d4578 100%);
      color: #fff;
      border-color: transparent;
    }

    .small-btn {
      width: auto;
      padding: 0 12px;
      font-size: 0.9rem;
      height: 36px;
    }

    /* ì˜µì…˜ íŒ¨ë„ */
    #tool-options {
      display: flex;
      gap: 10px;
      justify-content: center;
      align-items: center;
      margin-top: 5px;
      min-height: 40px;
      flex-wrap: wrap;
    }

    .size-indicator {
      font-size: 13px;
      color: #333;
      min-width: 30px;
      text-align: center;
      font-variant-numeric: tabular-nums;
    }

    input[type="color"] {
      width: 32px;
      height: 32px;
      border: 2px solid #e0e0e0;
      background: none;
      cursor: pointer;
      padding: 0;
      border-radius: 50%;
      overflow: hidden;
    }

    input[type="range"] {
      width: 100px;
      cursor: pointer;
      accent-color: #4a6fa5;
    }

    input[type="text"] {
      padding: 8px 10px;
      border: 2px solid #e0e0e0;
      border-radius: 10px;
      background: #fff;
      color: #222;
      width: 80px;
      text-align: center;
      font-size: 14px;
    }

    input[type="text"]:focus {
      outline: none;
      border-color: #4a6fa5;
    }

    .checkbox-label {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 13px;
      cursor: pointer;
      user-select: none;
    }

    /* ìë¥´ê¸° íŒ¨ë„ */
    #crop-panel {
      display: none;
      gap: 10px;
      justify-content: center;
      background: #f8f9fa;
      padding: 12px;
      border-radius: 12px;
      margin-bottom: 12px;
      flex-wrap: wrap;
      border: 2px solid #e0e0e0;
    }

    #crop-panel.active { display: flex; }

    /* í•˜ë‹¨ ë²„íŠ¼ ë° ë¦¬ì‚¬ì´ì¦ˆ ì»¨íŠ¸ë¡¤ */
    .action-panel {
      display: flex;
      flex-direction: column;
      gap: 15px;
      margin-top: 20px;
    }

    .resize-controls {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      flex-wrap: wrap;
      font-size: 14px;
      background: #f8f9fa;
      padding: 12px;
      border-radius: 12px;
      border: 2px solid #e0e0e0;
    }

    .resize-btns {
      display: flex;
      gap: 5px;
    }

    .resize-btns button {
      padding: 6px 10px;
      font-size: 13px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      background: #fff;
      cursor: pointer;
      color: #333;
      transition: all 0.2s;
    }

    .resize-btns button:hover {
      background: #e3f2fd;
      border-color: #4a6fa5;
    }

    .download-buttons {
      display: flex;
      gap: 10px;
    }

    .download-buttons button {
      flex: 1;
      border: none;
      padding: 16px;
      border-radius: 14px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }

    .download-buttons button:disabled {
      background: #e0e0e0;
      color: #999;
      cursor: not-allowed;
    }

    #reform-btn {
      background: linear-gradient(135deg, #ff8a65 0%, #ff7043 100%);
      color: #fff;
      box-shadow: 0 4px 15px rgba(255, 138, 101, 0.3);
    }

    #reform-btn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(255, 138, 101, 0.4);
    }

    #change-image-btn {
      width: 100%;
      background: #fff;
      color: #333;
      border: 2px solid #e0e0e0;
      padding: 12px;
      border-radius: 12px;
      font-weight: 600;
      cursor: pointer;
      margin-bottom: 12px;
      font-size: 14px;
      transition: all 0.2s;
    }

    #change-image-btn:hover {
      background: #e3f2fd;
      border-color: #4a6fa5;
    }

    /* í‘¸í„° */
    .footer {
      text-align: center;
      margin-top: 25px;
      font-size: 32px;
      animation: float-wave 3s ease-in-out infinite;
    }

    @keyframes float-wave {
      0%, 100% { transform: translateY(0) rotate(0deg); }
      25% { transform: translateY(-6px) rotate(-3deg); }
      75% { transform: translateY(-6px) rotate(3deg); }
    }

    @media (max-width: 480px) {
      .container { padding: 20px; }
      .tool-btn { width: 40px; height: 40px; font-size: 1.1rem; }
      h1 { font-size: 20px; }
      .header-btn { padding: 6px 10px; font-size: 13px; }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>ğŸ‘” ì´ë¯¸ì§€ ë¦¬í¼ì‹¤</h1>
      <div class="header-buttons">
        <a href="https://lagetom.github.io/ash4/" class="header-btn" title="ì´ë¯¸ì§€ ì„¸íƒì†Œ">ğŸ§¼</a>
        <a href="https://lagetom.github.io/ash5/" class="header-btn" title="ì´ë¯¸ì§€ ì‘ì—…ì‹¤">ğŸ–¼ï¸</a>
        <a href="https://lagetom.github.io/ash/" class="header-btn" title="ëŒì•„ê°€ê¸°">ğŸŒŠ</a>
      </div>
    </div>
    <p class="subtitle">ğŸ¨ JPG ë³€í™˜ (ë©”íƒ€ë°ì´í„° ì œê±°)<br>+ ğŸ§¶ ì§ì ‘ ê·¸ë ¤ì„œ ë¦¬í¼í•˜ê¸°</p>

    <div id="upload-box" class="upload-box">
      <span style="font-size: 2.5rem;">ğŸ–¼ï¸</span>
      <p>ì‘ì—…í•  ì´ë¯¸ì§€ë¥¼ ì—¬ê¸°ì— ì˜¬ë ¤ì£¼ì„¸ìš”</p>
    </div>
    <input type="file" id="file-input" accept="image/*" style="display: none;">
    <input type="file" id="layer-input" accept="image/*" style="display: none;">

    <div id="workspace">
      <button id="change-image-btn">ğŸ–¼ï¸ ë‹¤ë¥¸ ì‘ì—…ë¬¼ ê°€ì ¸ì˜¤ê¸°</button>

      <div id="crop-panel">
        <span style="font-size:0.9rem; align-self:center;">âœ‚ï¸ ì˜ì—­ì„ ë“œë˜ê·¸í•˜ì„¸ìš”</span>
        <button class="tool-btn small-btn active" id="btn-apply-crop" style="color:white; background:linear-gradient(135deg, #4a6fa5, #2d4578);">ì ìš©</button>
        <button class="tool-btn small-btn" id="btn-cancel-crop">ì·¨ì†Œ</button>
      </div>

      <div class="toolbar">
        <!-- 1ì¸µ: ê·¸ë¦¬ê¸° ë„êµ¬ -->
        <div class="tool-row">
          <button class="tool-btn active" id="tool-pen" title="íœ">ğŸ–Œï¸</button>
          <button class="tool-btn" id="tool-highlighter" title="í˜•ê´‘íœ">ğŸ–ï¸</button>
          <button class="tool-btn" id="tool-mosaic" title="ëª¨ìì´í¬">ğŸ’§</button>
          <button class="tool-btn" id="tool-eraser" title="ì§€ìš°ê°œ">ğŸ§½</button>
          <button class="tool-btn" id="tool-sticker" title="ì´ëª¨ì§€ ìŠ¤í‹°ì»¤">ğŸ˜‡</button>
          <button class="tool-btn" id="tool-patch" title="ë‹¨ìƒ‰ íŒ¨ì¹˜">ğŸ¡</button>
        </div>

        <!-- 2ì¸µ: ê¸°íƒ€ ë„êµ¬ -->
        <div class="tool-row">
          <button class="tool-btn" id="tool-text" title="í…ìŠ¤íŠ¸">T</button>
          <button class="tool-btn" id="tool-photo" title="ì‚¬ì§„ í•©ì¹˜ê¸°">ğŸ“¸</button>
          <button class="tool-btn" id="tool-crop" title="ìë¥´ê¸°">âœ‚ï¸</button>
          <button class="tool-btn" id="tool-filter" title="í‘ë°± í•„í„° ON/OFF">ğŸï¸</button>
          <button class="tool-btn" id="btn-undo" title="ë˜ëŒë¦¬ê¸°">â†©ï¸</button>
          <button class="tool-btn" id="btn-reset" title="ì´ˆê¸°í™”">ğŸ—‘ï¸</button>
        </div>

        <!-- ì˜µì…˜ íŒ¨ë„ -->
        <div id="tool-options"></div>
      </div>

      <div id="canvas-wrapper">
        <canvas id="main-canvas"></canvas>
        <div id="brush-cursor"></div>
      </div>

      <div class="action-panel">
        <div class="resize-controls">
          <label>ì¶œë ¥ í¬ê¸°:</label>
          <input type="number" id="img-width" placeholder="ë„ˆë¹„" style="width:70px; padding:8px; text-align:center;">
          <span>Ã—</span>
          <input type="number" id="img-height" placeholder="ë†’ì´" style="width:70px; padding:8px; text-align:center;" readonly>
          <div class="resize-btns">
            <button data-percent="0.25">25%</button>
            <button data-percent="0.5">50%</button>
            <button data-percent="0.75">75%</button>
            <button data-percent="1.0">100%</button>
          </div>
        </div>

        <div class="download-buttons">
          <button id="reform-btn" title="ë¦¬í¼ëœ ì´ë¯¸ì§€ë¥¼ ì €ì¥í•©ë‹ˆë‹¤.">ğŸ§¶ ë¦¬í¼ (ìˆ˜ì •ë³¸ ì €ì¥)</button>
        </div>
      </div>
    </div>

    <div class="footer">ğŸŒŠ</div>
  </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // [iOS ìµœì í™”] ë”ë¸” íƒ­ í™•ëŒ€ ë°©ì§€
    document.addEventListener('dblclick', function(event) { event.preventDefault(); }, { passive: false });

    // [ë‹¨ì¶•í‚¤ ì§€ì›] Ctrl+Z Undo
    document.addEventListener('keydown', (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
            e.preventDefault();
            if(history.length > 0) { history.pop(); redraw(); }
        }
    });

    // --- Elements ---
    const uploadBox = document.getElementById('upload-box');
    const fileInput = document.getElementById('file-input');
    const layerInput = document.getElementById('layer-input');
    const workspace = document.getElementById('workspace');
    const canvas = document.getElementById('main-canvas');
    const brushCursor = document.getElementById('brush-cursor');
    const canvasWrapper = document.getElementById('canvas-wrapper');
    const ctx = canvas.getContext('2d');
    const widthInput = document.getElementById('img-width');
    const heightInput = document.getElementById('img-height');
    const reformBtn = document.getElementById('reform-btn');
    const resizeBtns = document.querySelectorAll('.resize-btns button');

    // Tools Buttons
    const tools = {
        pen: document.getElementById('tool-pen'),
        highlighter: document.getElementById('tool-highlighter'),
        mosaic: document.getElementById('tool-mosaic'),
        eraser: document.getElementById('tool-eraser'),
        sticker: document.getElementById('tool-sticker'),
        patch: document.getElementById('tool-patch'),
        photo: document.getElementById('tool-photo'),
        text: document.getElementById('tool-text'),
        crop: document.getElementById('tool-crop'),
        filter: document.getElementById('tool-filter')
    };

    // UI Panels
    const toolOptions = document.getElementById('tool-options');
    const cropPanel = document.getElementById('crop-panel');
    const btnUndo = document.getElementById('btn-undo');
    const btnReset = document.getElementById('btn-reset');
    const btnApplyCrop = document.getElementById('btn-apply-crop');
    const btnCancelCrop = document.getElementById('btn-cancel-crop');

    // Options UI
    const elColor = document.createElement('input'); elColor.type = 'color'; elColor.value = '#000000';
    const elSize = document.createElement('input'); elSize.type = 'range'; elSize.min = 1; elSize.max = 100; elSize.value = 10;
    const elSizeLabel = document.createElement('span'); elSizeLabel.className = 'size-indicator'; elSizeLabel.textContent = '10';
    const elTextInput = document.createElement('input'); elTextInput.type = 'text'; elTextInput.placeholder = 'ë‚´ìš©';
    const elStickerInput = document.createElement('input'); elStickerInput.type = 'text'; elStickerInput.value = 'ğŸ˜º'; elStickerInput.style.width = '50px';
    const elBgCheck = document.createElement('input'); elBgCheck.type = 'checkbox';
    const elBgColor = document.createElement('input'); elBgColor.type = 'color'; elBgColor.value = '#ffffff'; elBgColor.disabled = true;
    const elPatchRect = document.createElement('button'); elPatchRect.className = 'tool-btn small-btn active'; elPatchRect.textContent = 'â– ';
    const elPatchCircle = document.createElement('button'); elPatchCircle.className = 'tool-btn small-btn'; elPatchCircle.textContent = 'â—';
    const elChangePhoto = document.createElement('button'); elChangePhoto.className = 'tool-btn small-btn'; elChangePhoto.textContent = 'ğŸ”„ ì‚¬ì§„ êµì²´';
    const lblBg = document.createElement('label'); lblBg.className = 'checkbox-label'; lblBg.appendChild(elBgCheck); lblBg.append(' ë°°ê²½');

    // Mosaic Options
    const elMosaicBlur = document.createElement('button'); elMosaicBlur.className = 'tool-btn small-btn active'; elMosaicBlur.textContent = 'ğŸ’§';
    const elMosaicPixel = document.createElement('button'); elMosaicPixel.className = 'tool-btn small-btn'; elMosaicPixel.textContent = 'â¬›';

    // State
    let originalImg = null;
    let customPhotoImg = null;
    let history = [];
    let currentMode = 'pen';
    let isDrawing = false;
    let currentPath = [];
    let patchShape = 'rect';
    let mosaicType = 'blur';
    let isFilterOn = false;

    let isCropping = false;
    let cropStart = null;
    let cropCurrent = null;

    // --- Functions ---
    function handleFile(file) {
        if (!file || !file.type.startsWith('image/')) return alert('ì´ë¯¸ì§€ íŒŒì¼ë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤.');
        const reader = new FileReader();
        reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
                originalImg = img;
                history = [];
                isFilterOn = false;
                tools.filter.classList.remove('active');
                widthInput.value = img.naturalWidth;
                heightInput.value = img.naturalHeight;
                initCanvas(img.naturalWidth, img.naturalHeight);
                uploadBox.style.display = 'none';
                workspace.style.display = 'block';
                updateUI();
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    }

    function handleLayerFile(file) {
        if (!file || !file.type.startsWith('image/')) return alert('ì´ë¯¸ì§€ íŒŒì¼ë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤.');
        const reader = new FileReader();
        reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
                customPhotoImg = img;
                setMode('photo');
                alert("ì‚¬ì§„ì´ ì¤€ë¹„ë˜ì—ˆìŠµë‹ˆë‹¤. ìº”ë²„ìŠ¤ë¥¼ í´ë¦­í•˜ì—¬ ë¶™ì—¬ë„£ìœ¼ì„¸ìš”.");
            };
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    }

    function initCanvas(w, h) {
        if (!originalImg) return;
        canvas.width = w; canvas.height = h;

        const wrapper = document.getElementById('canvas-wrapper');
        const maxWidth = Math.min(550, window.innerWidth - 60);
        let displayWidth = w; let displayHeight = h;

        if (displayWidth > maxWidth) {
            const ratio = maxWidth / displayWidth;
            displayWidth = maxWidth;
            displayHeight = h * ratio;
        }
        canvas.style.width = `${displayWidth}px`;
        canvas.style.height = `${displayHeight}px`;
        redraw();
    }

    function updateCanvasSize() {
        if(!originalImg) return;
        let newW = parseInt(widthInput.value);
        if(!newW || newW < 1) newW = 100;
        const ratio = originalImg.naturalHeight / originalImg.naturalWidth;
        const newH = Math.round(newW * ratio);
        heightInput.value = newH;
        initCanvas(newW, newH);
        updateCursor();
    }

    widthInput.addEventListener('input', updateCanvasSize);
    resizeBtns.forEach(btn => {
        btn.addEventListener('click', () => {
            if(!originalImg) return;
            const percent = parseFloat(btn.dataset.percent);
            widthInput.value = Math.round(originalImg.naturalWidth * percent);
            updateCanvasSize();
        });
    });

    // --- Brush Cursor Logic ---
    function updateCursor(e) {
        if (!originalImg || currentMode === 'crop') {
            brushCursor.style.display = 'none'; return;
        }

        const scale = canvas.offsetWidth / canvas.width;
        const realSize = parseInt(elSize.value);
        let displaySize = realSize * scale;

        brushCursor.textContent = '';
        brushCursor.style.borderRadius = '50%';
        brushCursor.style.border = '1px solid #fff';
        brushCursor.style.backgroundColor = 'transparent';
        brushCursor.style.width = `${displaySize}px`;
        brushCursor.style.height = `${displaySize}px`;

        if (currentMode === 'pen' || currentMode === 'highlighter') {
            brushCursor.style.backgroundColor = elColor.value;
            brushCursor.style.opacity = currentMode === 'highlighter' ? '0.3' : '0.5';
        }
        else if (currentMode === 'eraser') {
            brushCursor.style.backgroundColor = 'rgba(255,255,255,0.5)';
            brushCursor.style.border = '1px solid #000';
        }
        else if (currentMode === 'mosaic') {
            if (mosaicType === 'pixel') brushCursor.style.borderRadius = '0%';
            brushCursor.style.backgroundColor = 'rgba(0,0,0,0.1)';
            brushCursor.style.border = '1px dashed #fff';
        }
        else if (currentMode === 'sticker' || currentMode === 'text') {
            if(currentMode === 'text') displaySize *= 3;
            brushCursor.style.width = `${displaySize}px`;
            brushCursor.style.height = `${displaySize}px`;
            brushCursor.style.backgroundColor = 'rgba(0,0,0,0.1)';
            brushCursor.style.border = '1px dashed #4a6fa5';
        }
        else if (currentMode === 'patch') {
            brushCursor.style.backgroundColor = elColor.value;
            brushCursor.style.opacity = '0.7';
            if (patchShape === 'rect') brushCursor.style.borderRadius = '0%';
        }
        else if (currentMode === 'photo') {
            if (customPhotoImg) {
                const aspect = customPhotoImg.naturalWidth / customPhotoImg.naturalHeight;
                const targetH = (displaySize * 2) / aspect;
                brushCursor.style.width = `${displaySize * 2}px`;
                brushCursor.style.height = `${targetH}px`;
                brushCursor.style.borderRadius = '0%';
                brushCursor.style.border = '1px dashed #fff';
                brushCursor.style.backgroundColor = 'rgba(255,255,255,0.3)';
            } else {
                brushCursor.style.border = '1px dashed red';
            }
        }

        if (e) {
            const rect = canvasWrapper.getBoundingClientRect();
            if (e.clientX < rect.left || e.clientX > rect.right || e.clientY < rect.top || e.clientY > rect.bottom) {
                brushCursor.style.display = 'none';
            } else {
                brushCursor.style.display = 'flex';
                brushCursor.style.left = `${e.clientX - rect.left}px`;
                brushCursor.style.top = `${e.clientY - rect.top}px`;
            }
        }
    }

    canvasWrapper.addEventListener('mousemove', updateCursor);
    canvasWrapper.addEventListener('mouseleave', () => { brushCursor.style.display = 'none'; });

    // --- Drawing & Stamping ---
    function redraw() {
        if (!originalImg) return;
        ctx.filter = isFilterOn ? 'grayscale(100%)' : 'none';
        ctx.drawImage(originalImg, 0, 0, canvas.width, canvas.height);
        ctx.filter = 'none';

        history.forEach(item => {
            if (item.type === 'path') {
                ctx.beginPath();
                ctx.lineCap = (item.mode === 'mosaic' && item.subType === 'pixel') ? 'butt' : 'round';
                ctx.lineJoin = 'round';
                ctx.lineWidth = item.size;

                if (item.mode === 'eraser') {
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.strokeStyle = 'rgba(0,0,0,1)';
                } else if (item.mode === 'mosaic') {
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.strokeStyle = 'rgba(100,100,100,0.15)';
                } else if (item.mode === 'highlighter') {
                    ctx.globalCompositeOperation = 'multiply';
                    ctx.globalAlpha = 0.4;
                    ctx.strokeStyle = item.color;
                } else {
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.strokeStyle = item.color;
                }

                ctx.moveTo(item.points[0].x, item.points[0].y);
                for (let i = 1; i < item.points.length; i++) {
                    ctx.lineTo(item.points[i].x, item.points[i].y);
                }
                ctx.stroke();
                ctx.globalCompositeOperation = 'source-over';
                ctx.globalAlpha = 1.0;
            } else if (item.type === 'stamp') {
                ctx.font = `${item.size}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                if (item.bgColor) {
                    const metrics = ctx.measureText(item.text);
                    ctx.fillStyle = item.bgColor;
                    ctx.fillRect(item.x - metrics.width/2 - 5, item.y - item.size/2 - 5, metrics.width + 10, item.size + 10);
                }
                ctx.fillStyle = item.color || '#000';
                ctx.fillText(item.text, item.x, item.y);
            } else if (item.type === 'patch') {
                ctx.fillStyle = item.color;
                if (item.shape === 'rect') {
                    ctx.fillRect(item.x - item.size/2, item.y - item.size/2, item.size, item.size);
                } else {
                    ctx.beginPath();
                    ctx.arc(item.x, item.y, item.size/2, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (item.type === 'image' && item.img) {
                ctx.drawImage(item.img, item.x - item.width/2, item.y - item.height/2, item.width, item.height);
            }
        });

        if (currentMode === 'crop' && cropStart && cropCurrent) {
            ctx.strokeStyle = '#4a6fa5';
            ctx.lineWidth = 2;
            ctx.setLineDash([6, 3]);
            const x = Math.min(cropStart.x, cropCurrent.x);
            const y = Math.min(cropStart.y, cropCurrent.y);
            const w = Math.abs(cropCurrent.x - cropStart.x);
            const h = Math.abs(cropCurrent.y - cropStart.y);
            ctx.strokeRect(x, y, w, h);
            ctx.setLineDash([]);
        }

        reformBtn.disabled = false;
    }

    const getCoords = (e) => {
        const rect = canvas.getBoundingClientRect();
        const touch = e.touches ? e.touches[0] : e;
        return {
            x: touch.clientX - rect.left,
            y: touch.clientY - rect.top
        };
    };

    const startDraw = (e) => {
        const { x, y } = getCoords(e);
        if (currentMode === 'crop') { e.preventDefault(); isCropping = true; cropStart = { x, y }; cropCurrent = { x, y }; return; }
        const isPathTool = ['pen', 'highlighter', 'eraser', 'mosaic'].includes(currentMode);
        if (isPathTool) {
            isDrawing = true;
            const scaleX = originalImg.naturalWidth / canvas.width;
            const scaleY = originalImg.naturalHeight / canvas.height;
            currentPath = [{x: x * scaleX, y: y * scaleY}];
        }
    };

    const moveDraw = (e) => {
        const { x, y } = getCoords(e);
        if (currentMode === 'crop' && isCropping) { e.preventDefault(); cropCurrent = { x, y }; redraw(); return; }
        const isPathTool = ['pen', 'highlighter', 'eraser', 'mosaic'].includes(currentMode);
        if (!isDrawing || !isPathTool) return;
        e.preventDefault();
        const scaleX = originalImg.naturalWidth / canvas.width;
        const scaleY = originalImg.naturalHeight / canvas.height;
        currentPath.push({x: x * scaleX, y: y * scaleY});

        ctx.beginPath();
        ctx.lineCap = (currentMode === 'mosaic' && mosaicType === 'pixel') ? 'butt' : 'round';
        ctx.lineJoin = 'round';
        ctx.lineWidth = elSize.value;

        if (currentMode === 'eraser') { ctx.globalCompositeOperation = 'destination-out'; ctx.strokeStyle = 'rgba(0,0,0,1)'; }
        else if (currentMode === 'mosaic') { ctx.globalCompositeOperation = 'source-over'; ctx.strokeStyle = 'rgba(100,100,100,0.1)'; }
        else if (currentMode === 'highlighter') { ctx.globalCompositeOperation = 'multiply'; ctx.globalAlpha = 0.3; ctx.strokeStyle = elColor.value; }
        else { ctx.globalCompositeOperation = 'source-over'; ctx.strokeStyle = elColor.value; }

        const prevP = currentPath[currentPath.length-2];
        ctx.moveTo(prevP.x / scaleX, prevP.y / scaleY);
        ctx.lineTo(x, y);
        ctx.stroke();
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 1.0;
    };

    const endDraw = (e) => {
        if (currentMode === 'crop') { isCropping = false; return; }
        const isPathTool = ['pen', 'highlighter', 'eraser', 'mosaic'].includes(currentMode);
        const scaleX = originalImg.naturalWidth / canvas.width;
        if (isPathTool && isDrawing) {
            isDrawing = false;
            history.push({
                type: 'path', mode: currentMode, subType: mosaicType, color: elColor.value,
                size: parseInt(elSize.value) * scaleX, points: currentPath
            });
            redraw();
        } else if (!isPathTool) {
            const { x, y } = getCoords(e);
            let size = parseInt(elSize.value);
            const scaleY = originalImg.naturalHeight / canvas.height;
            if (currentMode === 'sticker') history.push({ type: 'stamp', text: elStickerInput.value || 'ğŸ˜º', x: x*scaleX, y: y*scaleY, size: size*scaleX });
            else if (currentMode === 'patch') history.push({ type: 'patch', shape: patchShape, color: elColor.value, x: x*scaleX, y: y*scaleY, size: size*scaleX });
            else if (currentMode === 'text') history.push({ type: 'stamp', text: elTextInput.value || 'í…ìŠ¤íŠ¸', x: x*scaleX, y: y*scaleY, size: (size*3)*scaleX, color: elColor.value, bgColor: elBgCheck.checked ? elBgColor.value : null });
            else if (currentMode === 'photo') {
                if (!customPhotoImg) { alert("ì‚¬ì§„ì„ ì„ íƒí•´ì£¼ì„¸ìš”."); layerInput.click(); return; }
                const aspect = customPhotoImg.naturalWidth / customPhotoImg.naturalHeight;
                history.push({ type: 'image', img: customPhotoImg, x: x*scaleX, y: y*scaleY, width: size*2*scaleX, height: (size*2/aspect)*scaleX });
            }
            redraw();
        }
    };

    canvas.addEventListener('mousedown', startDraw);
    canvas.addEventListener('mousemove', moveDraw);
    canvas.addEventListener('mouseup', endDraw);
    canvas.addEventListener('touchstart', startDraw, {passive: false});
    canvas.addEventListener('touchmove', moveDraw, {passive: false});
    canvas.addEventListener('touchend', endDraw);

    // Crop
    btnApplyCrop.addEventListener('click', () => {
        if (!cropStart || !cropCurrent) return alert('ìë¥¼ ì˜ì—­ì„ ì„ íƒí•´ì£¼ì„¸ìš”.');
        const x = Math.min(cropStart.x, cropCurrent.x);
        const y = Math.min(cropStart.y, cropCurrent.y);
        const w = Math.abs(cropCurrent.x - cropStart.x);
        const h = Math.abs(cropCurrent.y - cropStart.y);
        if (w < 10 || h < 10) return alert('ì˜ì—­ì´ ë„ˆë¬´ ì‘ìŠµë‹ˆë‹¤.');
        if(!confirm('ìë¥´ê¸°ë¥¼ ì ìš©í•˜ë©´ ê¸°ì¡´ í¸ì§‘ ë‚´ì—­ì´ ì´ˆê¸°í™”ë©ë‹ˆë‹¤.')) return;
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = w;
        tempCanvas.height = h;
        const tCtx = tempCanvas.getContext('2d');
        tCtx.filter = isFilterOn ? 'grayscale(100%)' : 'none';
        const scaleX = originalImg.naturalWidth / canvas.width;
        const scaleY = originalImg.naturalHeight / canvas.height;
        tCtx.drawImage(originalImg, x*scaleX, y*scaleY, w*scaleX, h*scaleY, 0, 0, w, h);
        const newImg = new Image();
        newImg.onload = () => {
            originalImg = newImg;
            widthInput.value = w;
            heightInput.value = h;
            history = [];
            cropStart = null;
            cropCurrent = null;
            isFilterOn = false;
            tools.filter.classList.remove('active');
            setMode('pen');
            initCanvas(w, h);
            updateUI();
        };
        newImg.src = tempCanvas.toDataURL();
    });
    btnCancelCrop.addEventListener('click', () => { setMode('pen'); redraw(); });

    // Mode Setting
    function setMode(mode) {
        if (mode === 'filter') {
            isFilterOn = !isFilterOn;
            tools.filter.classList.toggle('active', isFilterOn);
            redraw();
            return;
        }
        currentMode = mode;
        Object.values(tools).forEach(btn => { if(btn !== tools.filter) btn.classList.remove('active'); });
        if(tools[mode]) tools[mode].classList.add('active');
        cropPanel.classList.toggle('active', mode === 'crop');

        toolOptions.innerHTML = '';
        const crosshairTools = ['pen', 'highlighter', 'eraser', 'mosaic'];
        if(crosshairTools.includes(mode)) {
            if(mode !== 'eraser' && mode !== 'mosaic') toolOptions.appendChild(elColor);
            if(mode === 'mosaic') { toolOptions.appendChild(elMosaicBlur); toolOptions.appendChild(elMosaicPixel); }
            toolOptions.appendChild(elSize);
            toolOptions.appendChild(elSizeLabel);
        }
        if (mode === 'sticker') {
            toolOptions.appendChild(elStickerInput);
            toolOptions.appendChild(elSize);
            toolOptions.appendChild(elSizeLabel);
        }
        else if (mode === 'patch') {
            toolOptions.appendChild(elPatchRect);
            toolOptions.appendChild(elPatchCircle);
            toolOptions.appendChild(elColor);
            toolOptions.appendChild(elSize);
            toolOptions.appendChild(elSizeLabel);
        }
        else if (mode === 'text') {
            toolOptions.appendChild(elTextInput);
            toolOptions.appendChild(elColor);
            toolOptions.appendChild(elSize);
            toolOptions.appendChild(elSizeLabel);
            toolOptions.appendChild(lblBg);
            toolOptions.appendChild(elBgColor);
        }
        else if (mode === 'photo') {
            toolOptions.appendChild(elChangePhoto);
            toolOptions.appendChild(elSize);
            toolOptions.appendChild(elSizeLabel);
        }

        if (mode !== 'crop') redraw();
    }

    Object.keys(tools).forEach(key => tools[key].addEventListener('click', () => setMode(key)));
    elBgCheck.addEventListener('change', () => { elBgColor.disabled = !elBgCheck.checked; });
    elPatchRect.addEventListener('click', () => { patchShape = 'rect'; elPatchRect.classList.add('active'); elPatchCircle.classList.remove('active'); });
    elPatchCircle.addEventListener('click', () => { patchShape = 'circle'; elPatchCircle.classList.add('active'); elPatchRect.classList.remove('active'); });
    elMosaicBlur.addEventListener('click', () => { mosaicType = 'blur'; elMosaicBlur.classList.add('active'); elMosaicPixel.classList.remove('active'); });
    elMosaicPixel.addEventListener('click', () => { mosaicType = 'pixel'; elMosaicPixel.classList.add('active'); elMosaicBlur.classList.remove('active'); });
    elChangePhoto.addEventListener('click', () => { layerInput.click(); });
    elSize.addEventListener('input', () => { elSizeLabel.textContent = elSize.value; updateCursor(); });

    layerInput.addEventListener('change', e => { handleLayerFile(e.target.files[0]); e.target.value = ''; });
    btnUndo.addEventListener('click', () => { if(history.length > 0) { history.pop(); redraw(); } });
    btnReset.addEventListener('click', () => { if(confirm("ì´ˆê¸°í™”?")) { history = []; isFilterOn = false; tools.filter.classList.remove('active'); redraw(); } });

    reformBtn.addEventListener('click', () => {
        if (!originalImg) return;
        canvas.toBlob(blob => {
            const url = URL.createObjectURL(blob);
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
            if (isIOS) {
                alert("ì´ë¯¸ì§€ ê¸¸ê²Œ ëˆŒëŸ¬ ì €ì¥í•˜ì„¸ìš”.");
                window.open(url, '_blank');
            } else {
                const link = document.createElement('a');
                link.download = `reform_${Date.now()}.jpg`;
                link.href = url;
                link.click();
            }
        }, 'image/jpeg', 0.95);
    });

    document.getElementById('change-image-btn').addEventListener('click', () => fileInput.click());
    uploadBox.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', e => { handleFile(e.target.files[0]); e.target.value = ''; });

    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eName => {
        uploadBox.addEventListener(eName, e => { e.preventDefault(); e.stopPropagation(); });
    });
    uploadBox.addEventListener('dragenter', () => uploadBox.classList.add('dragover'));
    uploadBox.addEventListener('dragleave', () => uploadBox.classList.remove('dragover'));
    uploadBox.addEventListener('drop', e => { uploadBox.classList.remove('dragover'); handleFile(e.dataTransfer.files[0]); });

    updateUI = () => { reformBtn.disabled = true; };
});
</script>
</body>
</html>
